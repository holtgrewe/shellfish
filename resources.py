#!/usr/bin/env python3
"""This module contains classes for representing the static, global resources
and paths to them.

Resources are static file such as genomes, indices, but also databases that
are shared read-only by various programs.  The following resource types exist
and need to be versioned in the manner described below.

  Reference
    Reference sequence, corresponds to an assembly.  Usually, this will be
    a reference as stored in the NCBI database and not a UCSC reference since
    NCBI properly versionizes its sequences whereas UCSC goldenPath performs
    regular updates and so far we could not identify how to access a version
    number or previous versions.

    If a reference sequence provider does not release fixed versions then
    the download date is used as the version.

  Annotation
    Annotation database, as downloaded from a data source.  A popular example
    are is Ensembl.  Annotation databases always refer to a Reference and
    have a version by themselves.  For example, Ensembl-75 refers to the human
    reference GRCh37p14.

  PrecomputedData
    These are data sets that are generated or downloaded by programs.  A
    prominent example for such a program is SnpEff that provides annotation
    databases for different references and reference versions for any given
    SnpEff version.  Databases can be upgraded in between program upgrades
    for existing references and reference versions.  Thus, PrecomputedData
    is annotated with a tag (e.g., "index", "db"), the program name, the
    program version, a resource (can be a Reference or an Annotation) and
    a database version (that can be empty).

    In the case that the database version was accidently left empty and
    this is only noticed after a deploy, the program version needs to be
    bumped (e.g. to "1.2.3+cubi1"), such that all paths are backwards-
    compatible.

The doctest below the generated paths for each versionized resource.

Versions
--------

By default, we use the default program versions. In the case that there has
to be an update of the program (e.g. a patch) that is not reflected by the
program's version number, "intermediate versions" can be generated by
appending "+cubi${version}" to the official version, similar to how Debian
handles versioning.
"""

import os.path

# TODO(holtgrew): Actually implement

class ResourceBaseConfig:
    """Base configuration for CUBI resources.
    
    :param base_dir: base directory for resources
    :type str:
    :param config_dot_file: path to configuration dot-file
    :type str:
    """

    #: path to resource directory, defaults to `~/cubi_resources`
    base_dir = '~/cubi_resources'

    #: path to configuration dot-file
    config_dot_file = '~/.cubi_tools'

    def __init__(self, base_dir=None, config_dot_file=None):
        if base_dir is not None:
            self.base_dir = base_dir
        if config_dot_file is not None:
            self.config_dot_file = config_dot_file


class Resource:
    """Representation of a resource"""

    def __init__(self, files=[]):
        #: list of files that are stored under the resource's directory
        self.files = list(files)
        pass

    @property
    def path_token(self):
        """Compute identiyfing path infix for this resource."""
        pass

    def base_path(self, res_config):
        """Compute base path to the resource.

        :param res_config: ResourceBaseConfig configuration to use for
            generating the path
        """
        pass


class Reference(Resource):
    """A reference with a name and a (patch) version.

    .. note::

       In general, UCSC updates their data regularly without strictly
       versionizing it wheras the GRC has explicit path versions (starting
       at "p1" for their first patch).
   
    >>> Reference('grch37', 'p0')
    Reference('grch37', 'p0')
    >>> Reference('grch37', 'p0').path_token
    'grch37/p0'
    >>> Reference('grch37', 'p2')
    Reference('grch37', 'p2')
    >>> Reference('grch37', 'p2').path_token
    'grch37/p2'
    """

    def __init__(self, name, version):
        #: the reference's name, e.g., `'hg19'` or `'grch37'`
        self.name = name
        #: the reference's version, e.g. `'p0'`, `'p2'`
        self.version = version

    @property
    def path_token(self):
        return os.path.join(self.name, self.version)

    def to_path(self, res_config):
        return os.path.join(res_config.base_dir, 'reference', self.path_token)

    def __str__(self):
        return 'Reference({}, {})'.format(repr(self.name), repr(self.version))

    def __repr__(self):
        return str(self)


class Annotation(Resource):
    """Annotation database that refers to a specific Reference.
  
    >>> # human assembly v37 p14
    >>> grch37p14 = Annotation('ensembl', '75', Reference('grch37', 'p14'))
    >>> grch37p14
    Annotation('ensembl', '75', Reference('grch37', 'p14'))
    >>> grch37p14.path_token
    'ensembl/75/grch37/p14'
    >>> grch37p14.to_path(ResourceBaseConfig())
    '~/cubi_resources/annotation/ensembl/75/grch37/p14'
    >>> # Zebrafish assembly v9 p2
    >>> zv9p2 = Annotation('ensembl', '75', Reference('zv9', 'p2'))
    >>> zv9p2
    Annotation('ensembl', '75', Reference('zv9', 'p2'))
    >>> zv9p2.path_token
    'ensembl/75/zv9/p2'
    >>> zv9p2.to_path(ResourceBaseConfig())
    '~/cubi_resources/annotation/ensembl/75/zv9/p2'
    """

    def __init__(self, name, version, reference):
        #: name of the annotation, e.g., `'ensembl'`
        self.name = name
        #: the version of this Annotation, e.g. `'75'`
        self.version = version
        #: Reference that this Annotation is for
        self.reference = reference

    @property
    def path_token(self):
        return os.path.join(self.name, self.version, self.reference.path_token)

    def to_path(self, res_config):
        return os.path.join(res_config.base_dir, 'annotation', self.path_token)

    def __str__(self):
        return 'Annotation({}, {}, {})'.format(
                repr(self.name), repr(self.version), repr(self.reference))

    def __repr__(self):
        return str(self)


class PrecomputedData(Resource):
    """Precomputed data on another Resource.
    
    >>> # BWA index of human assembly v37 p14
    >>> idx = PrecomputedData('index', 'bwa', '0.7.12', Reference('grch37', 'p14'))
    >>> idx
    PrecomputedData('index', 'bwa', '0.7.12', Reference('grch37', 'p14'))
    >>> idx.path_token
    'index/bwa/0.7.12/grch37/p14'
    >>> idx.to_path(ResourceBaseConfig())
    '~/cubi_resources/index/bwa/0.7.12/grch37/p14'
    >>> # SnpEff database for human assembly v37 p14
    >>> db = PrecomputedData('db', 'snpeff', '4.1G', Reference('grch37', 'p14'),
    ...                      'v4_1_GRCh37.70')
    >>> db
    PrecomputedData('db', 'snpeff', '4.1G', Reference('grch37', 'p14'), 'v4_1_GRCh37.70')
    >>> db.path_token
    'db/snpeff/4.1G/v4_1_GRCh37.70/grch37/p14'
    >>> db.to_path(ResourceBaseConfig())
    '~/cubi_resources/db/snpeff/4.1G/v4_1_GRCh37.70/grch37/p14'
    """

    def __init__(self, tag, program, program_version, resource,
                 db_version=None):
        #: tag for the data, e.g., `'index'`
        self.tag = tag
        #: identifier of the program that is used for precomputation, e.g.,
        #: `'bwa'`
        self.program = program
        #: version of the program that was used for the precomputation, e.g.,
        #: `'0.7.1'`
        self.program_version = program_version
        #: Resource that the precomputation is fixed for, e.g. an Annotation
        #: or a Reference
        self.resource = resource
        #: explicit database version, e.g. 'GRCh37.65' for SnpEff, or `None`
        self.db_version = db_version

    @property
    def path_token(self):
        if self.db_version is None:
            return os.path.join(self.tag, self.program, self.program_version,
                                self.resource.path_token)
        else:
            return os.path.join(self.tag, self.program, self.program_version,
                                self.db_version, self.resource.path_token)

    def to_path(self, res_config):
        return os.path.join(res_config.base_dir, self.path_token)

    def __str__(self):
        suffix = ''
        if self.db_version:
            suffix = ', {}'.format(repr(self.db_version))
        return 'PrecomputedData({}, {}, {}, {}{})'.format(
                repr(self.tag), repr(self.program), repr(self.program_version),
                repr(self.resource), suffix)

    def __repr__(self):
        return str(self)


if __name__ == "__main__":
    import doctest
    doctest.testmod()
